/*
  Interactive cleaner for unused assets.

  Reads builds/asset-usage-report.json (generated by scripts/scan-asset-usage.js)
  and prompts to remove each unused asset (y/n).

  Flags:
    --report <path>   Use a custom report path
    --yes             Remove all unused assets without prompting
    --dry-run         Show what would be deleted, but don't delete
*/

const fs = require('fs');
const fsp = fs.promises;
const path = require('path');
const readline = require('readline');

const PROJECT_ROOT = path.resolve(__dirname, '..');
const ASSETS_ROOT = path.join(PROJECT_ROOT, 'src', 'assets');

function parseArgs(argv) {
  const args = {
    report: path.join(PROJECT_ROOT, 'builds', 'asset-usage-report.json'),
    yes: false,
    dryRun: false,
  };
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === '--report' && i + 1 < argv.length) {
      args.report = path.resolve(PROJECT_ROOT, argv[++i]);
    } else if (a === '--yes') {
      args.yes = true;
    } else if (a === '--dry-run') {
      args.dryRun = true;
    }
  }
  return args;
}

function loadReport(reportPath) {
  if (!fs.existsSync(reportPath)) {
    throw new Error(
      `Report not found at ${reportPath}. Run \`npm run assets:usage\` first.`,
    );
  }
  const raw = fs.readFileSync(reportPath, 'utf8');
  const data = JSON.parse(raw);
  if (!data || !Array.isArray(data.report)) {
    throw new Error('Invalid report format: missing report array.');
  }
  return data;
}

async function removeEmptyParentDirs(fileAbsPath) {
  let current = path.dirname(fileAbsPath);
  while (current.startsWith(ASSETS_ROOT) && current !== ASSETS_ROOT) {
    try {
      const entries = await fsp.readdir(current);
      if (entries.length === 0) {
        await fsp.rmdir(current);
        current = path.dirname(current);
      } else {
        break;
      }
    } catch (e) {
      break;
    }
  }
}

function createPrompt() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  const ask = (q) =>
    new Promise((resolve) => rl.question(q, (answer) => resolve(answer)));
  return {rl, ask};
}

async function main() {
  const args = parseArgs(process.argv);
  const reportData = loadReport(args.report);
  const unusedItems = reportData.report.filter((r) => r && r.used === false);

  if (unusedItems.length === 0) {
    console.log('No unused assets found in the report.');
    return;
  }

  console.log(
    `Found ${unusedItems.length} unused assets in ${path.relative(
      PROJECT_ROOT,
      args.report,
    )}.`,
  );
  if (args.dryRun) {
    console.log('Dry run enabled: no files will be deleted.');
  }

  const summary = {deleted: [], skipped: [], missing: []};
  const {rl, ask} = createPrompt();

  try {
    for (const item of unusedItems) {
      const relPath = item.asset; // already relative to project root
      const absPath = path.join(PROJECT_ROOT, relPath);

      const exists = fs.existsSync(absPath);
      if (!exists) {
        console.log(`Missing: ${relPath}`);
        summary.missing.push(relPath);
        continue;
      }

      let shouldDelete = false;
      if (args.yes) {
        shouldDelete = true;
      } else {
        const ans = (await ask(`Remove ${relPath}? [y/N] `))
          .trim()
          .toLowerCase();
        shouldDelete = ans === 'y';
      }

      if (!shouldDelete) {
        summary.skipped.push(relPath);
        continue;
      }

      if (args.dryRun) {
        console.log(`[dry-run] Would remove: ${relPath}`);
        summary.deleted.push(relPath);
        continue;
      }

      try {
        await fsp.unlink(absPath);
        await removeEmptyParentDirs(absPath);
        console.log(`Removed: ${relPath}`);
        summary.deleted.push(relPath);
      } catch (e) {
        console.error(`Failed to remove ${relPath}:`, e.message);
        summary.skipped.push(relPath);
      }
    }
  } finally {
    rl.close();
  }

  console.log('\nDone.');
  console.log(`Deleted: ${summary.deleted.length}`);
  console.log(`Skipped: ${summary.skipped.length}`);
  console.log(`Missing: ${summary.missing.length}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
